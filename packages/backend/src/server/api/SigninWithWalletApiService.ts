/*
 * SPDX-FileCopyrightText: syuilo and misskey-project
 * SPDX-License-Identifier: AGPL-3.0-only
 */

import { Inject, Injectable } from '@nestjs/common';
import { IsNull } from 'typeorm';
import { DI } from '@/di-symbols.js';
import type {
    SigninsRepository,
    UsersRepository,
} from '@/models/_.js';
import { IdService } from '@/core/IdService.js';
import { bindThis } from '@/decorators.js';
import { RateLimiterService } from './RateLimiterService.js';
import Logger from '@/logger.js';
import { LoggerService } from '@/core/LoggerService.js';
import type { FastifyReply, FastifyRequest } from 'fastify';

@Injectable()
export class SigninWithWalletApiService {
    private logger: Logger;

    constructor(
        @Inject(DI.usersRepository)
        private usersRepository: UsersRepository,
        @Inject(DI.signinsRepository)
        private signinsRepository: SigninsRepository,
        private idService: IdService,
        private rateLimiterService: RateLimiterService,
        private loggerService: LoggerService
    ) {
        this.logger = this.loggerService.getLogger('WalletAuth');
    }

    /**
     * Check if a user is already registered with the provided wallet address.
     * @param walletAddress The wallet address to check.
     * @returns True if the user exists, otherwise false.
     */
    @bindThis
    public async isUserRegistered(walletAddress: string): Promise<boolean> {
        const user = await this.usersRepository.findOneBy({
            walletAddress,
            host: IsNull(),
        });
        return user !== null;
    }

    @bindThis
    public async checkUser(
        request: FastifyRequest<{
            Body: {
                walletAddress: string;
            };
        }>,
        reply: FastifyReply
    ) {
        const { walletAddress } = request.body;

        // Validate input
        if (!walletAddress) {
            reply.code(400).send({ error: 'Missing walletAddress' });
            return;
        }

        try {
           // Check if the user is registered
           const isRegistered = await this.isUserRegistered(walletAddress);
           reply.send({ isRegistered });
        } catch (error) {
            this.logger.error(`Error checking user: ${error.message}`);
            reply.code(500).send({ error: 'Internal Server Error' });
        }
    }

    @bindThis
public async signin(
    request: FastifyRequest<{
        Body: {
            walletAddress: string;
            signedMessage: string;
            challenge: string; // Challenge string generated by the server
        };
    }>,
    reply: FastifyReply
) {
    reply.header('Access-Control-Allow-Origin', '*');
    reply.header('Access-Control-Allow-Credentials', 'true');

    const { walletAddress, signedMessage, challenge } = request.body;

    // Helper function to return errors
    function error(status: number, error: { id: string; message?: string }) {
        reply.code(status);
        return { error };
    }

    // Validate input
    if (!walletAddress || !signedMessage || !challenge) {
        return error(400, {
            id: 'invalid_request',
            message: 'Missing required fields: walletAddress, signedMessage, or challenge.',
        });
    }

    try {
        // Apply rate limiting
        await this.rateLimiterService.limit(
            { key: 'signin-with-wallet', duration: 10 * 60 * 1000, max: 100, minInterval: 250 },
            walletAddress
        );

        // Retrieve the stored challenge
        const storedChallenge = await this.cacheService.get(`wallet-challenge:${walletAddress}`);
        if (!storedChallenge || storedChallenge !== challenge) {
            return error(403, {
                id: 'invalid_challenge',
                message: 'The provided challenge is invalid or expired.',
            });
        }

        // Verify the signed challenge
        const isValid = this.verifyWalletSignature(walletAddress, signedMessage, challenge);
        if (!isValid) {
            return error(403, {
                id: 'invalid_signature',
                message: 'The provided signature is invalid.',
            });
        }

        // Check if user exists
        const user = await this.usersRepository.findOneBy({
            walletAddress,
            host: IsNull(),
        });

        if (!user) {
            return error(404, {
                id: 'user_not_found',
                message: 'No user found with the provided wallet address.',
            });
        }

        if (user.isSuspended) {
            return error(403, {
                id: 'user_suspended',
                message: 'The user is suspended.',
            });
        }

        // Log the successful signin
        await this.signinsRepository.insert({
            id: this.idService.gen(),
            userId: user.id,
            ip: request.ip,
            headers: request.headers as any,
            success: true,
        });

        // Generate session token and respond
        const sessionToken = this.generateSessionToken(user.id);
        return reply.send({
            userId: user.id,
            sessionToken,
            walletAddress: user.walletAddress,
        });
    } catch (error) {
        this.logger.error(`Signin error: ${error.message}`);
        return error(500, {
            id: 'internal_error',
            message: 'An error occurred during the signin process.',
        });
    }
   }

    /**
     * Mocked method to verify wallet signature.
     * Replace this with actual logic for verifying wallet signatures.
     */
    private verifyWalletSignature(walletAddress: string, signedMessage: string, challenge: string): boolean {
        // Mocked logic: In reality, you will verify the signedMessage against the walletAddress and challenge.
        return signedMessage === `Sign this message to authenticate: ${challenge}`;
    }

    /**
     * Mocked method to generate a session token.
     * Replace with your actual session/token logic.
     */
    private generateSessionToken(userId: string): string {
        return `session-${userId}-${Date.now()}`;
    }
 
    /**
    * Generate a challenge for wallet authentication.
    * @param walletAddress The wallet address to associate with the challenge.
    * @returns The generated challenge.
    */
    @bindThis
    public async generateChallenge(walletAddress: string): Promise<string> {
        if (!walletAddress) {
            throw new Error('Invalid wallet address');
        }

        const challenge = `Sign this message to authenticate: ${Date.now()} - ${walletAddress}`;
        await this.cacheService.set(`wallet-challenge:${walletAddress}`, challenge, 300); // Store for 5 minutes
        return challenge;
    }
}
